namespace NetEvolve.ForgingBlazor.Services;

using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using NetEvolve.ForgingBlazor.Extensibility.Abstractions;
using NetEvolve.ForgingBlazor.Extensibility.Models;

/// <summary>
/// Provides the default implementation of <see cref="IContentRegister"/> for the ForgingBlazor framework.
/// </summary>
/// <remarks>
/// <para>
/// This sealed partial class serves as the main content registration service for the ForgingBlazor dependency injection container.
/// It orchestrates the collection of content from multiple registered content segments and manages the registration of collected pages.
/// </para>
/// <para>
/// The class uses partial declarations to separate the main implementation logic from the logging method definitions
/// which are generated by the logging source generator.
/// </para>
/// </remarks>
/// <seealso cref="IContentRegister"/>
/// <seealso cref="IContentRegistration"/>
/// <seealso cref="IContentCollector"/>
internal sealed partial class ContentRegister : IContentRegister
{
    /// <summary>
    /// Stores the logger instance for logging content registration operations.
    /// </summary>
    /// <remarks>
    /// This field holds the logger used to record diagnostic messages about content collection and registration operations.
    /// </remarks>
    private readonly ILogger<ContentRegister> _logger;

    /// <summary>
    /// Stores the service provider for resolving content collectors and registrations.
    /// </summary>
    /// <remarks>
    /// This field holds the service provider used to retrieve content registrations and keyed content collectors
    /// during the content collection phase.
    /// </remarks>
    private readonly IServiceProvider _serviceProvider;

    /// <summary>
    /// Stores the collection of registered pages across all content segments.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This concurrent collection is thread-safe and allows multiple content collectors
    /// to register pages simultaneously without synchronization overhead.
    /// </para>
    /// <para>
    /// Pages are added to this collection via the <see cref="Register{TPageType}(TPageType)"/> method
    /// which is called by content collectors during the collection phase.
    /// </para>
    /// </remarks>
    private readonly ConcurrentBag<PageBase> _registeredPages = [];

    /// <summary>
    /// Initializes a new instance of the <see cref="ContentRegister"/> class with the specified dependencies.
    /// </summary>
    /// <param name="logger">
    /// The <see cref="ILogger{TCategoryName}"/> instance for logging registration operations.
    /// Cannot be <see langword="null"/>.
    /// </param>
    /// <param name="serviceProvider">
    /// The <see cref="IServiceProvider"/> for resolving content collectors and registrations.
    /// Cannot be <see langword="null"/>.
    /// </param>
    public ContentRegister(ILogger<ContentRegister> logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }

    /// <summary>
    /// Asynchronously collects content from all registered content segments using their associated collectors.
    /// </summary>
    /// <param name="cancellationToken">
    /// A token that can be used to request cancellation of the collection operation.
    /// Defaults to <see cref="CancellationToken.None"/> if not specified.
    /// </param>
    /// <returns>
    /// A <see cref="ValueTask"/> that represents the asynchronous content collection operation.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method performs the following steps:
    /// <list type="number">
    /// <item><description>Retrieves all <see cref="IContentRegistration"/> instances from the service provider</description></item>
    /// <item><description>Calls <see cref="UpdateRegistrations(IContentRegistration[])"/> to set exclude paths for default registrations</description></item>
    /// <item><description>Creates a concurrent dictionary to cache collectors by segment</description></item>
    /// <item><description>Iterates through registrations ordered by priority (descending)</description></item>
    /// <item><description>For each registration, retrieves the appropriate keyed collectors</description></item>
    /// <item><description>Executes each collector to collect and register content asynchronously</description></item>
    /// <item><description>Logs start/completion messages for each collection operation</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// The method uses <see cref="Parallel.ForEachAsync{TSource}(IAsyncEnumerable{TSource}, ParallelOptions, Func{TSource, CancellationToken, ValueTask})"/>
    /// to efficiently process multiple files in parallel during content collection.
    /// </para>
    /// </remarks>
    public async ValueTask CollectAsync(CancellationToken cancellationToken)
    {
        var registrations = _serviceProvider.GetServices<IContentRegistration>().ToArray();

        var contentCollectors = new ConcurrentDictionary<string, IEnumerable<IContentCollector>>(
            StringComparer.Ordinal
        );

        foreach (var registration in UpdateRegistrations(registrations))
        {
            var collectors = contentCollectors.GetOrAdd(
                registration.Segment,
                (segment) => _serviceProvider.GetKeyedServices<IContentCollector>(segment)
            );

            foreach (var collector in collectors)
            {
                var collectorTypeFullName = collector.GetType().Name;
                LogStartingContentCollection(registration.Segment, collectorTypeFullName);
                await collector.CollectAsync(this, registration, cancellationToken).ConfigureAwait(false);
                LogCompletedContentCollection(registration.Segment, collectorTypeFullName);
            }
        }
    }

    /// <summary>
    /// Registers a page with the content register.
    /// </summary>
    /// <typeparam name="TPageType">
    /// The page type that inherits from <see cref="PageBase"/>.
    /// </typeparam>
    /// <param name="page">
    /// The page instance to register. Cannot be <see langword="null"/>.
    /// </param>
    /// <remarks>
    /// This method adds the page to the internal collection of registered pages.
    /// It is thread-safe and can be called concurrently by multiple content collectors.
    /// </remarks>
    public void Register<TPageType>(TPageType page)
        where TPageType : PageBase => _registeredPages.Add(page);

    /// <summary>
    /// Updates the content registrations by configuring exclude paths for the default registration.
    /// </summary>
    /// <param name="registrations">
    /// The array of content registrations to update.
    /// Cannot be <see langword="null"/>.
    /// </param>
    /// <returns>
    /// An ordered array of content registrations, sorted by priority in descending order.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method identifies the default registration (implementing <see cref="IDefaultRegistration"/>) if present
    /// and sets its exclude paths to include all segments from other registrations, preventing the default collector
    /// from processing content that belongs to specific segments.
    /// </para>
    /// <para>
    /// The returned array is ordered by priority (<see cref="IContentRegistration.Priority"/>) in descending order
    /// to ensure content collectors are executed in the correct sequence, with highest priority collectors running first.
    /// </para>
    /// </remarks>
    private static IContentRegistration[] UpdateRegistrations(IContentRegistration[] registrations)
    {
        var defaultRegistrations =
            registrations.OfType<IDefaultRegistration>().FirstOrDefault()
            ?? throw new InvalidOperationException(
                "No default registration found. At least one registration must implement IDefaultRegistration."
            );
        var otherRegistrations = registrations.Except([defaultRegistrations!]).ToArray();

        var excludePaths = otherRegistrations.Select(registration => registration.Segment).ToArray();
        defaultRegistrations.SetExcludePaths(excludePaths);

        return [.. registrations.OrderByDescending(r => r.Priority)];
    }

    /// <summary>
    /// Logs that content collection has started for a specific segment and collector.
    /// </summary>
    /// <param name="segment">
    /// The name or identifier of the content segment being processed (e.g., <c>blog</c>, <c>docs</c>).
    /// </param>
    /// <param name="collectorType">
    /// The type name of the content collector being used.
    /// </param>
    /// <remarks>
    /// <para>
    /// This is a logging method generated by the logging source generator via the
    /// <see cref="LoggerMessageAttribute"/> annotation.
    /// </para>
    /// <para>
    /// It logs at <see cref="LogLevel.Debug"/> level with <c>EventId = 0</c>.
    /// </para>
    /// </remarks>
    [LoggerMessage(
        EventId = 0,
        Level = LogLevel.Debug,
        Message = "Starting content collection for segment '{Segment}' using collector '{CollectorType}'."
    )]
    private partial void LogStartingContentCollection(string segment, string collectorType);

    /// <summary>
    /// Logs that content collection has completed for a specific segment and collector.
    /// </summary>
    /// <param name="segment">
    /// The name or identifier of the content segment that was processed (e.g., <c>blog</c>, <c>docs</c>).
    /// </param>
    /// <param name="collectorType">
    /// The type name of the content collector that was used.
    /// </param>
    /// <remarks>
    /// <para>
    /// This is a logging method generated by the logging source generator via the
    /// <see cref="LoggerMessageAttribute"/> annotation.
    /// </para>
    /// <para>
    /// It logs at <see cref="LogLevel.Debug"/> level with <c>EventId = 1</c>.
    /// </para>
    /// </remarks>
    [LoggerMessage(
        EventId = 1,
        Level = LogLevel.Debug,
        Message = "Completed content collection for segment '{Segment}' using collector '{CollectorType}'."
    )]
    private partial void LogCompletedContentCollection(string segment, string collectorType);
}
